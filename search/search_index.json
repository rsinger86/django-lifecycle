{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Django Lifecycle Hooks","text":"<p>This project provides a <code>@hook</code> decorator as well as a base model and mixin to add lifecycle hooks to your Django models. Django's built-in approach to offering lifecycle hooks is Signals. However, my team often finds that Signals introduce unnecessary indirection and are at odds with Django's \"fat models\" approach.</p> <p>In short, you can write model code like this:</p> <pre><code>from django_lifecycle import LifecycleModel, hook, BEFORE_UPDATE, AFTER_UPDATE\n\n\nclass Article(LifecycleModel):\n    contents = models.TextField()\n    updated_at = models.DateTimeField(null=True)\n    status = models.ChoiceField(choices=['draft', 'published'])\n    editor = models.ForeignKey(AuthUser)\n\n    @hook(\n        BEFORE_UPDATE, \n        condition=WhenFieldHasChanged('contents', has_changed=True),\n    )\n    def on_content_change(self):\n        self.updated_at = timezone.now()\n\n    @hook(\n        AFTER_UPDATE, \n        condition=(\n            WhenFieldValueWas(\"status\", value=\"draft\")\n            &amp; WhenFieldValueIs(\"status\", value=\"published\")\n        )\n    )\n    def on_publish(self):\n        send_email(self.editor.email, \"An article has published!\")\n</code></pre> <p>Instead of overriding <code>save</code> and <code>__init__</code> in a clunky way that hurts readability:</p> <pre><code>    # same class and field declarations as above ...\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._orig_contents = self.contents\n        self._orig_status = self.status\n\n\n    def save(self, *args, **kwargs):\n        if self.pk is not None and self.contents != self._orig_contents):\n            self.updated_at = timezone.now()\n\n        super().save(*args, **kwargs)\n\n        if self.status != self._orig_status:\n            send_email(self.editor.email, \"An article has published!\")\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python (3.7+)</li> <li>Django (2.2+)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install django-lifecycle\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Either extend the provided abstract base model class:</p> <pre><code>from django_lifecycle import LifecycleModel, hook\n\n\nclass YourModel(LifecycleModel):\n    name = models.CharField(max_length=50)\n</code></pre> <p>Or add the mixin to your Django model definition:</p> <pre><code>from django.db import models\nfrom django_lifecycle import LifecycleModelMixin, hook\n\n\nclass YourModel(LifecycleModelMixin, models.Model):\n    name = models.CharField(max_length=50)\n</code></pre>"},{"location":"#optional-add-django_lifecycle_checks-to-your-installed_apps","title":"(Optional) Add <code>django_lifecycle_checks</code> to your <code>INSTALLED_APPS</code>","text":"<pre><code>INSTALLED_APPS = [\n    # ...\n    \"django_lifecycle_checks\",\n    # ...\n]\n</code></pre> <p>This will raise an exception if you forget to add the mixin or extend the base model class.</p> <p>Read on to see more examples of how to use lifecycle hooks.</p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#utility-methods","title":"Utility Methods","text":"<p>These are available on your model instance when the mixin or extend the base model is used.</p> Method Details <code>has_changed(field_name: str) -&gt; bool</code> Return a boolean indicating whether the field's value has changed since the model was initialized, or refreshed from db <code>initial_value(field_name: str) -&gt; Any</code> Return the value of the field when the model was first initialized, or refreshed from db"},{"location":"advanced/#example","title":"Example","text":"<p>You can use these methods for more advanced checks, for example:</p> <pre><code>from django_lifecycle import LifecycleModel, AFTER_UPDATE, hook\n\n\nclass UserAccount(LifecycleModel):\n    first_name = models.CharField(max_length=100)\n    last_name = models.CharField(max_length=100)\n    email = models.CharField(max_length=100)\n    marital_status = models.CharField(max_length=100)\n\n    @hook(AFTER_UPDATE)\n    def on_name_change_heck_on_marital_status(self):\n        if (\n            self.has_changed('last_name') \n            and not self.has_changed('marital_status')\n        ):\n            send_mail(\n                to=self.email, \n                \"Has your marital status changed recently?\"\n            )\n</code></pre>"},{"location":"advanced/#custom-conditions","title":"Custom conditions","text":"<p>Custom conditions can be created as long as they respect condition signature <pre><code>def changes_to_ned_flanders(instance, update_fields=None) -&gt; bool:\n    return (\n        instance.has_changed(\"first_name\") \n        and instance.has_changed(\"last_name\")\n        and instance.first_name == \"Ned\"\n        and instance.last_name == \"Flanders\"\n    )\n</code></pre></p> <p>To allow your custom conditions to be chainable, create a class based condition inheriting <code>ChainableCondition</code>. <pre><code>from django_lifecycle import BEFORE_SAVE\nfrom django_lifecycle.conditions import WhenFieldHasChanged\nfrom django_lifecycle.conditions.base import ChainableCondition\n\n\nclass IsNedFlanders(ChainableCondition):\n    def __call__(self, instance, update_fields=None):\n        return (\n            instance.first_name == \"Ned\" \n            and instance.last_name == \"Flanders\"\n        )\n\n\n@hook(\n    BEFORE_SAVE,\n    condition=(\n        WhenFieldHasChanged(\"first_name\")\n        &amp; WhenFieldHasChanged(\"last_name\")\n        &amp; IsNedFlanders()\n    )\n)\ndef foo():\n    ...\n</code></pre></p>"},{"location":"advanced/#suppressing-hooked-methods","title":"Suppressing Hooked Methods","text":"<p>To prevent the hooked methods from being called, pass <code>skip_hooks=True</code> when calling save:</p> <pre><code>   account.save(skip_hooks=True)\n</code></pre> <p>Or, you can rely on the <code>bypass_hooks_for</code> context manager:</p> <pre><code>from django_lifecycle import bypass_hooks_for\n\n\nclass MyModel(LifecycleModel):\n    @hook(AFTER_CREATE)\n    def trigger(self):\n        pass\n\nwith bypass_hooks_for((MyModel,)):\n    model = MyModel()\n    model.save()  # will not invoke model.trigger() method\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Here are some examples to illustrate how you can hook into specific lifecycle moments, optionally based on state transitions.</p>"},{"location":"examples/#specific-lifecycle-moments","title":"Specific lifecycle moments","text":"<p>For simple cases, you might always want something to happen at a certain point, such as after saving or before deleting a model instance. When a user is first created, you could process a thumbnail image in the background and send the user an email:</p> <pre><code>    @hook(AFTER_CREATE)\n    def do_after_create_jobs(self):\n        enqueue_job(process_thumbnail, self.picture_url)\n\n        mail.send_mail(\n            'Welcome!', 'Thank you for joining.',\n            'from@example.com', ['to@example.com'],\n        )\n</code></pre> <p>Or you want to email a user when their account is deleted. You could add the decorated method below:</p> <pre><code>    @hook(AFTER_DELETE)\n    def email_deleted_user(self):\n        mail.send_mail(\n            'We have deleted your account', 'We will miss you!.',\n            'customerservice@corporate.com', ['human@gmail.com'],\n        )\n</code></pre> <p>Or if you want to enqueue a background job that depends on state being committed to your database</p> <pre><code>@hook(AFTER_CREATE, on_commit=True)\ndef do_after_create_jobs(self):\n    enqueue_job(send_item_shipped_notication, self.item_id)\n</code></pre> <p>Read on to see how to only fire the hooked method if certain conditions about the model's current and previous state are met.</p>"},{"location":"examples/#transitions-between-specific-values","title":"Transitions between specific values","text":"<p>Maybe you only want the hooked method to run under certain circumstances related to the state of your model. If a model's <code>status</code> field change from <code>\"active\"</code> to <code>\"banned\"</code>, you may want to send an email to the user:</p> <pre><code>@hook(\n    AFTER_UPDATE, \n    condition=(\n        WhenFieldValueWas(\"status\", value=\"active\") \n        &amp; WhenFieldValueIs('status', value='banned')\n    )\n)\ndef email_banned_user(self):\n    mail.send_mail(\n        'You have been banned', 'You may or may not deserve it.',\n        'communitystandards@corporate.com', ['mr.troll@hotmail.com'],\n    )\n</code></pre> <p>The <code>WhenFieldValueWas</code> and <code>WhenFieldValueIs</code> conditions allow you to compare the model's state from when it was first instantiated to the current moment. You can also pass <code>\"*\"</code> to indicate any value - these are the defaults, meaning that by default the hooked method will fire. </p>"},{"location":"examples/#preventing-state-transitions","title":"Preventing state transitions","text":"<p>You can also enforce certain disallowed transitions. For example, maybe you don't want your staff to be able to delete an active trial because they should expire instead:</p> <pre><code>@hook(BEFORE_DELETE, condition=WhenFieldValueIs(\"has_trial\", value=True))\ndef ensure_trial_not_active(self):\n    raise CannotDeleteActiveTrial('Cannot delete trial user!')\n</code></pre>"},{"location":"examples/#any-change-to-a-field","title":"Any change to a field","text":"<p>You can use the <code>WhenFieldValueChangesTo</code> condition to run the hooked method if a field has changed.</p> <pre><code>@hook(BEFORE_UPDATE, condition=WhenFieldHasChanged(\"address\", has_changed=True))\ndef timestamp_address_change(self):\n    self.address_updated_at = timezone.now()\n</code></pre>"},{"location":"examples/#when-a-fields-value-is-not","title":"When a field's value is NOT","text":"<p>You can have a hooked method fire when a field's value IS NOT equal to a certain value.</p> <pre><code>@hook(BEFORE_SAVE, condition=WhenFieldValueIsNot(\"email\", value=None))\ndef lowercase_email(self):\n    self.email = self.email.lower()\n</code></pre>"},{"location":"examples/#when-a-fields-value-was-not","title":"When a field's value was NOT","text":"<p>You can have a hooked method fire when a field's initial value was not equal to a specific value.</p> <pre><code>@hook(\n    BEFORE_SAVE, \n    condition=(\n        WhenFieldValueWasNot(\"status\", value=\"rejected\") \n        &amp; WhenFieldValueIs(\"status\", value=\"published\")\n    )\n)\ndef send_publish_alerts(self):\n    send_mass_email()\n</code></pre>"},{"location":"examples/#when-a-fields-value-changes-to","title":"When a field's value changes to","text":"<p>You can have a hooked method fire when a field's initial value was not equal to a specific value but now is.</p> <pre><code>    @hook(BEFORE_SAVE, condition=WhenFieldValueChangesTo(\"status\", value=\"published\"))\n    def send_publish_alerts(self):\n        send_mass_email()\n</code></pre> <p>Generally, <code>WhenFieldValueChangesTo</code> is a shorthand for the situation when <code>WhenFieldValueWasNot</code> and <code>WhenFieldValueIs</code>  conditions have the same value. The sample above is equal to:</p> <pre><code>@hook(\n    BEFORE_SAVE, \n    condition=(\n        WhenFieldValueWasNot(\"status\", value=\"published\")\n        &amp; WhenFieldValueIs(\"status\", value=\"published\")\n    )\n)\ndef send_publish_alerts(self):\n    send_mass_email()\n</code></pre>"},{"location":"examples/#stacking-decorators","title":"Stacking decorators","text":"<p>You can decorate the same method multiple times if you want to hook a method to multiple moments.</p> <pre><code>@hook(AFTER_UPDATE, condition=WhenFieldHasChanged(\"published\", has_changed=True))\n@hook(AFTER_CREATE, condition=WhenFieldHasChanged(\"type\", has_changed=True))\ndef handle_update(self):\n    # do something\n</code></pre>"},{"location":"examples/#going-deeper-with-utility-methods","title":"Going deeper with utility methods","text":"<p>If you need to hook into events with more complex conditions, you can write your own conditions, or take advantage of <code>has_changed</code> and <code>initial_value</code> utility methods:</p> <pre><code>@hook(AFTER_UPDATE)\ndef on_update(self):\n    if self.has_changed('username') and not self.has_changed('password'):\n        # do the thing here\n        if self.initial_value('login_attempts') == 2:\n            do_thing()\n        else:\n            do_other_thing()\n</code></pre>"},{"location":"fk_changes/","title":"Watching Changes to ForeignKey Fields","text":""},{"location":"fk_changes/#foreignkey-reference-changes","title":"ForeignKey Reference Changes","text":"<p>You can watch whether a foreign key reference changes by putting the name of the FK field in the <code>when</code> parameter:</p> <pre><code>class Organization(models.Model):\n    name = models.CharField(max_length=100)\n\n\nclass UserAccount(LifecycleModel):\n    username = models.CharField(max_length=100)\n    email = models.CharField(max_length=600)\n    employer = models.ForeignKey(Organization, on_delete=models.SET_NULL)\n\n    @hook(AFTER_UPDATE, condition=WhenFieldHasChanged(\"employer\", has_changed=True))\n    def notify_user_of_employer_change(self):\n        mail.send_mail(\"Update\", \"You now work for someone else!\", [self.email])\n</code></pre> <p>To be clear: This hook will fire when the value in the database column that stores the foreign key (in this case, <code>organization_id</code>) changes. Read on to see how to watch for changes to fields on the related model.</p>"},{"location":"fk_changes/#foreignkey-field-value-changes","title":"ForeignKey Field Value Changes","text":"<p>You can have a hooked method fire based on the value of a field on a foreign key-related model using dot-notation:</p> <p><pre><code>class Organization(models.Model):\n    name = models.CharField(max_length=100)\n\n\nclass UserAccount(LifecycleModel):\n    username = models.CharField(max_length=100)\n    email = models.CharField(max_length=600)\n    employer = models.ForeignKey(Organization, on_delete=models.SET_NULL)\n\n    @hook(AFTER_UPDATE, condition=WhenFieldValueChangesTo(\"employer.name\", value=\"Google\"))\n    def notify_user_of_google_buy_out(self):\n        mail.send_mail(\"Update\", \"Google bought your employer!\", [\"to@example.com\"],)\n</code></pre> If you use dot-notation,  Please be aware of the potential performance hit: When your model is first initialized, the related model will also be loaded in order to store the \"initial\" state of the related field. Models set up with these hooks should always be loaded using <code>.select_related()</code>, i.e. <code>UserAccount.objects.select_related(\"organization\")</code> for the example above. If you don't do this, you will almost certainly experience a major N+1 performance problem.</p>"},{"location":"hooks_and_conditions/","title":"Available Hooks &amp; Conditions","text":"<p>You can hook into one or more lifecycle moments by adding the <code>@hook</code> decorator to a model's method. The moment name is passed as the first positional argument, <code>@hook(BEFORE_CREATE)</code>, and optional keyword arguments can be passed to set up conditions for when the method should fire.</p>"},{"location":"hooks_and_conditions/#decorator-signature","title":"Decorator Signature","text":"<pre><code>@hook(\n    moment: str,\n    condition: Optional[types.Condition] = None,\n    priority: int = DEFAULT_PRIORITY,\n    on_commit: Optional[bool] = None,\n\n    # Legacy parameters\n    when: str = None,\n    when_any: List[str] = None,\n    has_changed: bool = None,\n    is_now: Any = '*',\n    is_not: Any = None,\n    was: Any = '*',\n    was_not: Any = None,\n    changes_to: Any = None,\n)\n</code></pre>"},{"location":"hooks_and_conditions/#lifecycle-moments","title":"Lifecycle Moments","text":"<p>Below is a full list of hooks, in the same order in which they will get called during the respective operations:</p> Hook constant Hook name When it fires <code>BEFORE_SAVE</code> before_save Immediately before <code>save</code> is called <code>AFTER_SAVE</code> after_save Immediately after <code>save</code> is called <code>BEFORE_CREATE</code> before_create Immediately before <code>save</code> is called, if <code>pk</code> is <code>None</code> <code>AFTER_CREATE</code> after_create Immediately after <code>save</code> is called, if <code>pk</code> was initially <code>None</code> <code>BEFORE_UPDATE</code> before_update Immediately before <code>save</code> is called, if <code>pk</code> is NOT <code>None</code> <code>AFTER_UPDATE</code> after_update Immediately after <code>save</code> is called, if <code>pk</code> was NOT <code>None</code> <code>BEFORE_DELETE</code> before_delete Immediately before <code>delete</code> is called <code>AFTER_DELETE</code> after_delete Immediately after <code>delete</code> is called <p>All of hook constants are strings containing the specific hook name, for example <code>AFTER_UPDATE</code> is string <code>\"after_update\"</code> - preferably way is to use hook constant.</p>"},{"location":"hooks_and_conditions/#conditions","title":"Conditions","text":"<p>You can add a condition to specify in which case the hook will be fired or not, depending on the initial or current  state of a model instance's fields.</p> <p>There are some conditions already implemented, but you can provide your own condition, or even chain them using <code>&amp;</code> and <code>|</code>.</p> <ul> <li><code>WhenFieldHasChanged(field_name, has_changed)</code></li> <li><code>WhenFieldValueIs(field_name, value)</code></li> <li><code>WhenFieldValueIsNot(field_name, value)</code></li> <li><code>WhenFieldValueWas(field_name, value)</code></li> <li><code>WhenFieldValueWasNot(field_name, value)</code></li> <li><code>WhenFieldValueChangesTo(field_name, value)</code></li> </ul>"},{"location":"hooks_and_conditions/#chaining-conditions","title":"Chaining conditions","text":"<p>Conditions can be chained using <code>&amp;</code> and <code>|</code> boolean operators</p> <pre><code>from django_lifecycle.conditions import WhenFieldValueChangesTo\nfrom django_lifecycle import hook, BEFORE_UPDATE\n\n@hook(\n    BEFORE_UPDATE, \n    condition=(\n        WhenFieldValueChangesTo(\"first_name\", value=\"Ned\")\n        &amp; WhenFieldValueChangesTo(\"last_name\", value=\"Flanders\")\n    )\n)\ndef do_something(self):\n    ...\n</code></pre>"},{"location":"hooks_and_conditions/#legacy-condition-keyword-arguments","title":"Legacy Condition Keyword Arguments","text":"<p>If you do not use any conditional parameters, the hook will fire every time the lifecycle moment occurs. You can use the keyword arguments below to conditionally fire the method depending on the initial or current state of a model instance's fields.</p> Keyword arg Type Details when str The name of the field that you want to check against; required for the conditions below to be checked. Use the name of a FK field to watch changes to the related model reference or use dot-notation to watch changes to the values of fields on related models, e.g. <code>\"organization.name\"</code>. But please be aware of potential performance drawbacks. when_any List[str] Similar to the <code>when</code> parameter, but takes a list of field names. The hooked method will fire if any of the corresponding fields meet the keyword conditions. Useful if you don't like stacking decorators. has_changed bool Only fire the hooked method if the value of the <code>when</code> field has changed since the model was initialized is_now Any Only fire the hooked method if the value of the <code>when</code> field is currently equal to this value; defaults to <code>*</code>. is_not Any Only fire the hooked method if the value of the <code>when</code> field is NOT equal to this value was Any Only fire the hooked method if the value of the <code>when</code> field was equal to this value when first initialized; defaults to <code>*</code>. was_not Any Only fire the hooked method if the value of the <code>when</code> field was NOT equal to this value when first initialized. changes_to Any Only fire the hooked method if the value of the <code>when</code> field was NOT equal to this value when first initialized but is currently equal to this value. priority int Specify the priority, useful when some hooked methods depend on other ones. on_commit bool When <code>True</code> only fire the hooked method after the current database transaction has been commited or not at all. (Only applies to <code>AFTER_*</code> hooks)"}]}